<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Islamic Sites Atlas (MyData)</title>
    <!-- Author: Yasin Ullah, Pakistani -->

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <style>
        /* --- General Styles --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        #app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* --- Map Styles --- */
        #map-container {
            flex: 3; /* Map takes more space */
            position: relative;
            overflow: hidden;
            min-height: 400px; /* Ensure map has a minimum height */
        }

        #map {
            width: 100%;
            height: 100%;
            background-color: #cceeff; /* Base map color before tiles load */
        }

        #map-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000; /* Above map tiles */
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            display: flex;
            gap: 5px;
        }

        #map-controls input[type="text"],
        #map-controls button {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        #map-controls button {
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
        }

        #map-controls button:hover {
            background-color: #0056b3;
        }


        /* --- Sidebar Styles --- */
        #sidebar {
            flex: 1; /* Sidebar takes less space */
            background-color: #fff;
            border-left: 1px solid #ddd;
            overflow-y: auto; /* Scrollable sidebar content */
            padding: 15px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            min-width: 280px; /* Minimum width for sidebar */
            max-width: 400px; /* Maximum width */
            display: flex;
            flex-direction: column;
        }

        #sidebar h2 {
            color: #007bff;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
         #sidebar h2:first-child {
             margin-top: 0;
         }

        #filter-controls, #data-management-controls {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        #filter-controls label {
            margin-right: 5px;
        }

        #filter-controls select,
        #filter-controls input[type="text"] {
            padding: 5px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
         #filter-controls input[type="text"] {
             width: calc(100% - 12px); /* Adjust width considering padding/border */
             margin-top: 5px;
             margin-right: 0;
         }


        #site-list, #trail-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1; /* Allow lists to take available space */
        }

        .site-item, .trail-item {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .site-item:hover, .trail-item:hover {
            background-color: #e9e9e9;
        }

        .site-item h3, .trail-item h3 {
            margin: 0 0 5px 0;
            color: #0056b3;
        }

        .site-item p, .trail-item p {
            margin: 0 0 3px 0;
            font-size: 0.9em;
            color: #555;
        }
         .site-item .visited-status {
             font-weight: bold;
             color: green;
         }
         .site-item .not-visited-status {
             font-weight: bold;
             color: orange;
         }

        #add-trail-btn,
        #backup-data-btn,
        #restore-data-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            text-align: center;
            transition: background-color 0.2s ease;
        }

        #add-trail-btn:hover,
        #backup-data-btn:hover,
        #restore-data-btn:hover {
            background-color: #218838;
        }
         #restore-data-btn {
             background-color: #ffc107;
             color: #333;
         }
         #restore-data-btn:hover {
             background-color: #e0a800;
         }


        /* --- Modal Styles --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 2000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            padding-top: 60px;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto; /* 5% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 90%; /* Could be more responsive */
            max-width: 600px; /* Max width */
            border-radius: 8px;
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .modal-content h2 {
            margin-top: 0;
            color: #007bff;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .modal-content label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .modal-content input[type="text"],
        .modal-content input[type="number"],
        .modal-content select,
        .modal-content textarea {
            width: calc(100% - 22px); /* Adjust for padding and border */
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        .modal-content textarea {
            resize: vertical; /* Allow vertical resizing */
            min-height: 80px;
        }

         .modal-content input[type="checkbox"] {
             margin-right: 5px;
             vertical-align: middle;
         }
         .modal-content label[for="site-visited"] {
             display: inline-block;
             margin-bottom: 15px;
             font-weight: normal;
         }


        .modal-content button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 10px;
            transition: background-color 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #0056b3;
        }

        #delete-site-btn, #delete-trail-btn {
            background-color: #dc3545;
        }
        #delete-site-btn:hover, #delete-trail-btn:hover {
            background-color: #c82333;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        #site-photo-preview {
            display: block;
            margin-top: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            padding: 5px;
            background-color: #eee;
        }

        #trail-site-selector {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        #trail-site-selector label {
            display: block;
            margin-bottom: 5px;
            font-weight: normal;
            cursor: pointer;
        }
        #trail-site-selector input[type="checkbox"] {
             margin-right: 8px;
        }


        /* --- Confirmation Modal --- */
         #confirm-modal .modal-content {
             max-width: 400px;
             text-align: center;
         }
         #confirm-modal button {
             margin: 0 10px;
         }
         #confirm-modal #confirm-yes {
             background-color: #dc3545;
         }
          #confirm-modal #confirm-yes:hover {
             background-color: #c82333;
         }
          #confirm-modal #confirm-no {
             background-color: #6c757d;
         }
          #confirm-modal #confirm-no:hover {
             background-color: #5a6268;
         }


        /* --- Custom Marker Styles (Cartographic Futuristic / Glowing) --- */
        /* Base Icon Style */
        .site-icon {
            width: 30px;
            height: 30px;
            background-color: #007bff; /* Default Blue */
            border: 2px solid #fff;
            border-radius: 50%;
            text-align: center;
            line-height: 26px;
            color: white;
            font-weight: bold;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.7); /* Glowing effect */
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* Type-based Colors */
        .site-icon.type-Masjid { background-color: #28a745; box-shadow: 0 0 8px rgba(40, 167, 69, 0.7); } /* Green */
        .site-icon.type-Tomb { background-color: #ffc107; box-shadow: 0 0 8px rgba(255, 193, 7, 0.7); } /* Yellow */
        .site-icon.type-HistoricalSite { background-color: #17a2b8; box-shadow: 0 0 8px rgba(23, 162, 184, 0.7); } /* Cyan */
        .site-icon.type-Other { background-color: #6c757d; box-shadow: 0 0 8px rgba(108, 117, 125, 0.7); } /* Grey */

        /* Visited Status Overlay/Effect */
        .site-icon.visited {
             /* Maybe a different border or a pulse animation */
             border-color: #00ff00; /* Bright green border */
             box-shadow: 0 0 12px rgba(0, 255, 0, 0.9), 0 0 5px rgba(0, 255, 0, 0.5) inset; /* Stronger green glow */
             animation: pulse-visited 1.5s infinite alternate;
        }

        @keyframes pulse-visited {
            from {
                box-shadow: 0 0 12px rgba(0, 255, 0, 0.9), 0 0 5px rgba(0, 255, 0, 0.5) inset;
            }
            to {
                 box-shadow: 0 0 18px rgba(0, 255, 0, 1), 0 0 8px rgba(0, 255, 0, 0.8) inset;
            }
        }


        /* Styling for the default Leaflet popup */
        .leaflet-popup-content-wrapper {
             border-radius: 5px;
        }
        .leaflet-popup-content {
            margin: 0;
            padding: 5px 10px;
            font-size: 0.9em;
            line-height: 1.4;
        }
        .leaflet-popup-content h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #007bff;
        }
         .leaflet-popup-content p {
             margin-bottom: 3px;
         }
         .leaflet-popup-content p strong {
             color: #555;
         }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            #app-container {
                flex-direction: column;
            }

            #map-container {
                flex: none; /* Remove flex grow */
                width: 100%;
                height: 60vh; /* Map takes 60% of viewport height on small screens */
                min-height: 300px;
            }

            #sidebar {
                flex: none; /* Remove flex grow */
                width: 100%;
                min-width: auto;
                max-width: none;
                height: 40vh; /* Sidebar takes 40% of viewport height */
                border-left: none;
                border-top: 1px solid #ddd;
            }

            #map-controls {
                 top: auto;
                 bottom: 10px;
                 left: 50%;
                 transform: translateX(-50%);
                 width: calc(100% - 20px);
                 flex-wrap: wrap; /* Allow controls to wrap */
                 justify-content: center;
            }
             #map-controls input[type="text"] {
                 flex-grow: 1; /* Search input takes available space */
                 min-width: 150px;
             }
             #map-controls button {
                 flex-shrink: 0; /* Buttons don't shrink */
             }

            .modal-content {
                margin: 10% auto; /* Adjust top margin for smaller screens */
                width: 95%;
            }
        }

         /* --- Footer --- */
         footer {
             text-align: center;
             padding: 10px;
             background-color: #eee;
             font-size: 0.8em;
             color: #555;
         }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="map-container">
            <div id="map"></div>
            <div id="map-controls">
                <input type="text" id="nominatim-search" placeholder="Search locations...">
                <button id="search-location-btn">Search</button>
                <button id="my-location-btn">My Location</button>
            </div>
        </div>
        <div id="sidebar">
            <h2>My Sites</h2>
            <div id="filter-controls">
                 <label for="filter-type">Type:</label>
                 <select id="filter-type">
                     <option value="">All Types</option>
                     <option value="Masjid">Masjid</option>
                     <option value="Tomb">Tomb</option>
                     <option value="Historical Site">Historical Site</option>
                     <option value="Other">Other</option>
                 </select>
                 <label for="filter-visited">Visited:</label>
                 <select id="filter-visited">
                     <option value="">All Statuses</option>
                     <option value="true">Visited</option>
                     <option value="false">Not Visited</option>
                 </select>
                 <input type="text" id="site-search" placeholder="Search sites...">
            </div>
            <ul id="site-list">
                <!-- Site list items populated by JS -->
            </ul>

            <h2>My Trails</h2>
             <ul id="trail-list">
                <!-- Trail list items populated by JS -->
            </ul>
            <button id="add-trail-btn">Create New Trail</button>

            <h2>Data Management</h2>
            <div id="data-management-controls">
                <button id="backup-data-btn">Backup Data</button>
                <input type="file" id="restore-file-input" accept=".json" style="display: none;">
                <button id="restore-data-btn">Restore Data</button>
            </div>
        </div>
    </div>

    <!-- Site Modal -->
    <div id="site-modal" class="modal">
        <div class="modal-content">
            <span class="close site-modal-close">Ã—</span>
            <h2 id="site-modal-title">Add New Site</h2>
            <input type="hidden" id="site-id">
            <label for="site-name">Name:</label><input type="text" id="site-name" required><br>
            <label for="site-lat">Latitude:</label><input type="number" id="site-lat" step="any" required><br>
            <label for="site-lng">Longitude:</label><input type="number" id="site-lng" step="any" required><br>
            <label for="site-type">Type:</label>
            <select id="site-type" required>
                <option value="Masjid">Masjid</option>
                <option value="Tomb">Tomb</option>
                <option value="Historical Site">Historical Site</option>
                <option value="Other">Other</option>
            </select><br>
            <label for="site-significance">Historical Significance:</label><textarea id="site-significance"></textarea><br>
            <label for="site-duas">Related Duas/Practices:</label><textarea id="site-duas"></textarea><br>
            <label for="site-notes">Personal Visit Notes:</label><textarea id="site-notes"></textarea><br>
            <label for="site-photo">Photo:</label><input type="file" id="site-photo" accept="image/*"><br>
            <img id="site-photo-preview" src="" alt="Photo Preview" style="max-width: 100px; max-height: 100px; display: none;"><br>
            <label for="site-visited">Visited:</label><input type="checkbox" id="site-visited"><br>
            <label for="site-quran">Related Quran/Hadith:</label><textarea id="site-quran"></textarea><br>
            <button id="save-site-btn">Save Site</button>
            <button id="delete-site-btn" style="display: none;">Delete Site</button>
        </div>
    </div>

     <!-- Trail Modal -->
     <div id="trail-modal" class="modal">
        <div class="modal-content">
            <span class="close trail-modal-close">Ã—</span>
            <h2 id="trail-modal-title">Create New Trail</h2>
            <input type="hidden" id="trail-id">
            <label for="trail-name">Trail Name:</label><input type="text" id="trail-name" required><br>
            <label for="trail-description">Description:</label><textarea id="trail-description"></textarea><br>
            <h3>Select Sites for Trail:</h3>
            <div id="trail-site-selector">
                <!-- Checkboxes for sites populated by JS -->
            </div>
            <button id="save-trail-btn">Save Trail</button>
             <button id="delete-trail-btn" style="display: none;">Delete Trail</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirm-modal" class="modal">
        <div class="modal-content">
            <p id="confirm-message"></p>
            <button id="confirm-yes">Yes</button>
            <button id="confirm-no">No</button>
        </div>
    </div>

    <footer>Authored by Yasin Ullah, Pakistani</footer>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // --- Global Variables ---
        let map;
        let db;
        const DB_NAME = 'islamicSitesDBw';
        const DB_VERSION = 2; // Increment version for schema changes (e.g., adding trails)
        const SITE_STORE_NAME = 'sites';
        const TRAIL_STORE_NAME = 'trails';

        let siteMarkers = new Map(); // Map siteId -> Leaflet marker
        let trailPolylines = new Map(); // Map trailId -> Leaflet polyline

        let allSites = []; // Cache of all sites from DB
        let allTrails = []; // Cache of all trails from DB

        // --- IndexedDB Functions ---

        /**
         * Opens the IndexedDB database.
         * @returns {Promise<IDBDatabase>} A promise that resolves with the database instance.
         */
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    // Create site store if it doesn't exist
                    if (!db.objectStoreNames.contains(SITE_STORE_NAME)) {
                        const siteStore = db.createObjectStore(SITE_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        // siteStore.createIndex('name', 'name', { unique: false }); // Example index
                    }
                    // Create trail store if it doesn't exist
                    if (!db.objectStoreNames.contains(TRAIL_STORE_NAME)) {
                         const trailStore = db.createObjectStore(TRAIL_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                    console.log(`IndexedDB upgrade complete to version ${DB_VERSION}`);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB opened successfully');
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.error);
                    alert('Failed to open database. Some features may not work.');
                    reject(event.target.error);
                };
            });
        }

        /**
         * Performs a transaction on the database.
         * @param {string[]} storeNames - Array of store names involved in the transaction.
         * @param {string} mode - Transaction mode ('readonly' or 'readwrite').
         * @returns {IDBTransaction} The transaction object.
         */
        function getObjectStore(storeNames, mode) {
            const transaction = db.transaction(storeNames, mode);
            transaction.onerror = (event) => console.error(`Transaction error on ${storeNames}:`, event.target.error);
            transaction.oncomplete = () => console.log(`Transaction on ${storeNames} complete.`);
            return transaction;
        }

        /**
         * Adds or updates a site in IndexedDB.
         * @param {object} siteData - The site data object.
         * @returns {Promise<number>} A promise that resolves with the site ID.
         */
        function saveSiteDB(siteData) {
            return new Promise((resolve, reject) => {
                const transaction = getObjectStore([SITE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SITE_STORE_NAME);
                const request = siteData.id ? store.put(siteData) : store.add(siteData);

                request.onsuccess = (event) => {
                    const siteId = siteData.id || event.target.result;
                    console.log(`Site ${siteData.id ? 'updated' : 'added'} with ID: ${siteId}`);
                    resolve(siteId);
                };
                request.onerror = (event) => {
                    console.error('Error saving site:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * Deletes a site from IndexedDB.
         * @param {number} siteId - The ID of the site to delete.
         * @returns {Promise<void>} A promise that resolves when deletion is complete.
         */
        function deleteSiteDB(siteId) {
             return new Promise(async (resolve, reject) => {
                 try {
                     // First, remove the site from any trails it belongs to
                     const trailsToUpdate = allTrails.filter(trail => trail.siteIds.includes(siteId));
                     for (const trail of trailsToUpdate) {
                         trail.siteIds = trail.siteIds.filter(id => id !== siteId);
                         await saveTrailDB(trail); // Update the trail in DB
                     }

                     // Then, delete the site itself
                     const transaction = getObjectStore([SITE_STORE_NAME], 'readwrite');
                     const store = transaction.objectStore(SITE_STORE_NAME);
                     const request = store.delete(siteId);

                     request.onsuccess = () => {
                         console.log(`Site deleted with ID: ${siteId}`);
                         resolve();
                     };
                     request.onerror = (event) => {
                         console.error('Error deleting site:', event.target.error);
                         reject(event.target.error);
                     };
                 } catch (error) {
                     reject(error);
                 }
            });
        }

        /**
         * Retrieves all sites from IndexedDB.
         * @returns {Promise<object[]>} A promise that resolves with an array of site objects.
         */
        function getAllSitesDB() {
            return new Promise((resolve, reject) => {
                const transaction = getObjectStore([SITE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(SITE_STORE_NAME);
                const request = store.getAll();

                request.onsuccess = (event) => {
                    console.log('All sites retrieved:', event.target.result);
                    resolve(event.target.result || []);
                };
                request.onerror = (event) => {
                    console.error('Error getting all sites:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

         /**
         * Adds or updates a trail in IndexedDB.
         * @param {object} trailData - The trail data object.
         * @returns {Promise<number>} A promise that resolves with the trail ID.
         */
        function saveTrailDB(trailData) {
            return new Promise((resolve, reject) => {
                const transaction = getObjectStore([TRAIL_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(TRAIL_STORE_NAME);
                const request = trailData.id ? store.put(trailData) : store.add(trailData);

                request.onsuccess = (event) => {
                    const trailId = trailData.id || event.target.result;
                    console.log(`Trail ${trailData.id ? 'updated' : 'added'} with ID: ${trailId}`);
                    resolve(trailId);
                };
                request.onerror = (event) => {
                    console.error('Error saving trail:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

         /**
         * Deletes a trail from IndexedDB.
         * @param {number} trailId - The ID of the trail to delete.
         * @returns {Promise<void>} A promise that resolves when deletion is complete.
         */
        function deleteTrailDB(trailId) {
            return new Promise((resolve, reject) => {
                const transaction = getObjectStore([TRAIL_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(TRAIL_STORE_NAME);
                const request = store.delete(trailId);

                request.onsuccess = () => {
                    console.log(`Trail deleted with ID: ${trailId}`);
                    resolve();
                };
                request.onerror = (event) => {
                    console.error('Error deleting trail:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * Retrieves all trails from IndexedDB.
         * @returns {Promise<object[]>} A promise that resolves with an array of trail objects.
         */
        function getAllTrailsDB() {
            return new Promise((resolve, reject) => {
                const transaction = getObjectStore([TRAIL_STORE_NAME], 'readonly');
                const store = transaction.objectStore(TRAIL_STORE_NAME);
                const request = store.getAll();

                request.onsuccess = (event) => {
                    console.log('All trails retrieved:', event.target.result);
                    resolve(event.target.result || []);
                };
                request.onerror = (event) => {
                    console.error('Error getting all trails:', event.target.error);
                    reject(event.target.error);
                };
            });
        }


        // --- Map Functions ---

        function initMap() {
            // Initialize map - Default view (e.g., Pakistan or a central Islamic location)
            map = L.map('map').setView([30.3753, 69.3451], 6); // Centered near Pakistan

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add click listener to map to add a new site
            map.on('click', onMapClick);
        }

        function onMapClick(e) {
            // Open the site modal pre-filled with clicked coordinates
            openSiteModal({ lat: e.latlng.lat, lng: e.latlng.lng });
        }

        function createSiteMarker(siteData) {
            const iconClass = `site-icon type-${siteData.type.replace(/\s+/g, '')} ${siteData.visited ? 'visited' : ''}`;
            const siteIcon = L.divIcon({
                className: iconClass,
                html: 'ðŸ•Œ', // Simple icon representation
                iconSize: [30, 30],
                iconAnchor: [15, 15], // Center the icon
                popupAnchor: [0, -15] // Position popup above icon
            });

            const marker = L.marker([siteData.lat, siteData.lng], { icon: siteIcon });

            // Create popup content
            let popupContent = `<h4>${siteData.name || 'Unnamed Site'}</h4>`;
            popupContent += `<p><strong>Type:</strong> ${siteData.type || 'N/A'}</p>`;
            popupContent += `<p><strong>Visited:</strong> ${siteData.visited ? 'Yes' : 'No'}</p>`;
             if (siteData.historicalSignificance) {
                 popupContent += `<p><strong>Significance:</strong> ${siteData.historicalSignificance.substring(0, 100)}...</p>`;
             }
             if (siteData.notes) {
                 popupContent += `<p><strong>Notes:</strong> ${siteData.notes.substring(0, 100)}...</p>`;
             }


            marker.bindPopup(popupContent);

            // Add click listener to marker to open edit modal
            marker.on('click', () => {
                openSiteModal(siteData);
            });

            return marker;
        }

        function addSiteToMap(siteData) {
            const marker = createSiteMarker(siteData);
            marker.addTo(map);
            siteMarkers.set(siteData.id, marker);
        }

        function removeSiteFromMap(siteId) {
            const marker = siteMarkers.get(siteId);
            if (marker) {
                map.removeLayer(marker);
                siteMarkers.delete(siteId);
            }
        }

        function refreshMapMarkers() {
            // Clear existing markers
            siteMarkers.forEach(marker => map.removeLayer(marker));
            siteMarkers.clear();

            // Get current filters
            const filterType = document.getElementById('filter-type').value;
            const filterVisited = document.getElementById('filter-visited').value;
            const searchTerm = document.getElementById('site-search').value.toLowerCase();

            // Filter sites
            const filteredSites = allSites.filter(site => {
                const typeMatch = filterType === '' || site.type === filterType;
                const visitedMatch = filterVisited === '' || String(site.visited) === filterVisited;
                const searchMatch = searchTerm === '' ||
                                    (site.name && site.name.toLowerCase().includes(searchTerm)) ||
                                    (site.notes && site.notes.toLowerCase().includes(searchTerm)) ||
                                    (site.historicalSignificance && site.historicalSignificance.toLowerCase().includes(searchTerm)) ||
                                    (site.duas && site.duas.toLowerCase().includes(searchTerm)) ||
                                     (site.quran && site.quran.toLowerCase().includes(searchTerm));
                return typeMatch && visitedMatch && searchMatch;
            });

            // Add filtered sites to map
            filteredSites.forEach(site => addSiteToMap(site));
        }

         function createTrailPolyline(trailData) {
             const siteCoords = trailData.siteIds
                 .map(siteId => allSites.find(site => site.id === siteId))
                 .filter(site => site && site.lat && site.lng) // Filter out sites not found or missing coords
                 .map(site => [site.lat, site.lng]);

             if (siteCoords.length < 2) {
                 console.warn(`Trail "${trailData.name}" does not have enough sites with coordinates to draw.`);
                 return null; // Cannot draw a polyline with less than 2 points
             }

             const polyline = L.polyline(siteCoords, {
                 color: '#8A2BE2', // BlueViolet
                 weight: 4,
                 opacity: 0.7,
                 dashArray: '10, 5' // Dashed line for trail
             });

             // Create popup content for the trail
             let popupContent = `<h4>Trail: ${trailData.name || 'Unnamed Trail'}</h4>`;
             if (trailData.description) {
                 popupContent += `<p>${trailData.description}</p>`;
             }
             popupContent += `<p>Sites: ${trailData.siteIds.length}</p>`;

             polyline.bindPopup(popupContent);

             // Add click listener to open edit modal (optional, could also use list)
             // polyline.on('click', () => { openTrailModal(trailData); });

             return polyline;
         }

         function addTrailToMap(trailData) {
             const polyline = createTrailPolyline(trailData);
             if (polyline) {
                 polyline.addTo(map);
                 trailPolylines.set(trailData.id, polyline);
             }
         }

         function removeTrailFromMap(trailId) {
             const polyline = trailPolylines.get(trailId);
             if (polyline) {
                 map.removeLayer(polyline);
                 trailPolylines.delete(trailId);
             }
         }

         function refreshMapPolylines() {
             // Clear existing polylines
             trailPolylines.forEach(polyline => map.removeLayer(polyline));
             trailPolylines.clear();

             // Add all current trails to map
             allTrails.forEach(trail => addTrailToMap(trail));
         }


        // --- UI Population Functions ---

        function renderSiteList(sitesToRender) {
            const siteListElement = document.getElementById('site-list');
            siteListElement.innerHTML = ''; // Clear current list

            if (!sitesToRender || sitesToRender.length === 0) {
                siteListElement.innerHTML = '<li>No sites found. Click on the map to add one!</li>';
                return;
            }

            sitesToRender.forEach(site => {
                const listItem = document.createElement('li');
                listItem.classList.add('site-item');
                listItem.dataset.siteId = site.id;
                const visitedStatusClass = site.visited ? 'visited-status' : 'not-visited-status';
                const visitedStatusText = site.visited ? 'Visited' : 'Not Visited';

                listItem.innerHTML = `
                    <h3>${site.name || 'Unnamed Site'}</h3>
                    <p>Type: ${site.type || 'N/A'}</p>
                    <p class="${visitedStatusClass}">${visitedStatusText}</p>
                `;

                listItem.addEventListener('click', () => {
                    // Pan map to site location
                    map.setView([site.lat, site.lng], 14); // Zoom in slightly
                    // Optionally open marker popup
                    const marker = siteMarkers.get(site.id);
                    if (marker) {
                        marker.openPopup();
                    }
                    // Optionally open edit modal immediately
                    // openSiteModal(site);
                });

                siteListElement.appendChild(listItem);
            });
        }

        function renderTrailList(trailsToRender) {
             const trailListElement = document.getElementById('trail-list');
             trailListElement.innerHTML = ''; // Clear current list

             if (!trailsToRender || trailsToRender.length === 0) {
                 trailListElement.innerHTML = '<li>No trails created yet.</li>';
                 return;
             }

             trailsToRender.forEach(trail => {
                 const listItem = document.createElement('li');
                 listItem.classList.add('trail-item');
                 listItem.dataset.trailId = trail.id;

                 listItem.innerHTML = `
                     <h3>${trail.name || 'Unnamed Trail'}</h3>
                     <p>${trail.description ? trail.description.substring(0, 100) + '...' : 'No description'}</p>
                     <p>Sites: ${trail.siteIds ? trail.siteIds.length : 0}</p>
                 `;

                 listItem.addEventListener('click', () => {
                     // Find the polyline and maybe fit bounds or just show info
                     const polyline = trailPolylines.get(trail.id);
                     if (polyline) {
                         map.fitBounds(polyline.getBounds());
                         polyline.openPopup();
                     }
                     // Open edit modal
                     openTrailModal(trail);
                 });

                 trailListElement.appendChild(listItem);
             });
         }

         function populateTrailSiteSelector(selectedSiteIds = []) {
             const selectorDiv = document.getElementById('trail-site-selector');
             selectorDiv.innerHTML = ''; // Clear current options

             if (allSites.length === 0) {
                 selectorDiv.innerHTML = '<p>No sites available to add to a trail.</p>';
                 return;
             }

             allSites.forEach(site => {
                 const checkboxId = `trail-site-${site.id}`;
                 const isSelected = selectedSiteIds.includes(site.id);

                 const label = document.createElement('label');
                 label.setAttribute('for', checkboxId);

                 const checkbox = document.createElement('input');
                 checkbox.type = 'checkbox';
                 checkbox.id = checkboxId;
                 checkbox.value = site.id;
                 checkbox.checked = isSelected;

                 label.appendChild(checkbox);
                 label.appendChild(document.createTextNode(site.name || `Unnamed Site (ID: ${site.id})`));

                 selectorDiv.appendChild(label);
             });
         }


        // --- Modal & Form Handling ---

        const siteModal = document.getElementById('site-modal');
        const trailModal = document.getElementById('trail-modal');
        const confirmModal = document.getElementById('confirm-modal');

        // Get the <span> element that closes the modal
        const siteModalClose = siteModal.querySelector('.close');
        const trailModalClose = trailModal.querySelector('.close');

        // When the user clicks on <span> (x), close the modal
        siteModalClose.onclick = () => siteModal.style.display = 'none';
        trailModalClose.onclick = () => trailModal.style.display = 'none';

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = (event) => {
            if (event.target === siteModal) {
                siteModal.style.display = 'none';
            }
             if (event.target === trailModal) {
                 trailModal.style.display = 'none';
             }
             if (event.target === confirmModal) {
                 confirmModal.style.display = 'none';
             }
        }

        function openSiteModal(siteData = {}) {
            const isEdit = siteData.id !== undefined;
            document.getElementById('site-modal-title').textContent = isEdit ? 'Edit Site' : 'Add New Site';
            document.getElementById('delete-site-btn').style.display = isEdit ? 'inline-block' : 'none';

            // Populate form fields
            document.getElementById('site-id').value = siteData.id || '';
            document.getElementById('site-name').value = siteData.name || '';
            document.getElementById('site-lat').value = siteData.lat || '';
            document.getElementById('site-lng').value = siteData.lng || '';
            document.getElementById('site-type').value = siteData.type || 'Masjid';
            document.getElementById('site-significance').value = siteData.historicalSignificance || '';
            document.getElementById('site-duas').value = siteData.duas || '';
            document.getElementById('site-notes').value = siteData.notes || '';
            document.getElementById('site-visited').checked = siteData.visited || false;
            document.getElementById('site-quran').value = siteData.quran || '';

            // Handle photo preview
            const photoPreview = document.getElementById('site-photo-preview');
            if (siteData.photo) {
                photoPreview.src = siteData.photo;
                photoPreview.style.display = 'block';
            } else {
                photoPreview.src = '';
                photoPreview.style.display = 'none';
            }
             // Clear file input for security reasons (cannot set value programmatically)
             document.getElementById('site-photo').value = '';


            siteModal.style.display = 'block';
        }

                async function getSiteFormData() {
            const id = document.getElementById('site-id').value ? parseInt(document.getElementById('site-id').value) : undefined;
            const name = document.getElementById('site-name').value.trim();
            const lat = parseFloat(document.getElementById('site-lat').value);
            const lng = parseFloat(document.getElementById('site-lng').value);
            const type = document.getElementById('site-type').value;
            const significance = document.getElementById('site-significance').value.trim();
            const duas = document.getElementById('site-duas').value.trim();
            const notes = document.getElementById('site-notes').value.trim();
            const visited = document.getElementById('site-visited').checked;
            const quran = document.getElementById('site-quran').value.trim();
            const photoInput = document.getElementById('site-photo');
            let photo = document.getElementById('site-photo-preview').src; // Keep existing photo if no new one uploaded

            // Handle new photo upload
            if (photoInput.files && photoInput.files[0]) {
                const file = photoInput.files[0];
                // Basic file size check (e.g., limit to 2MB)
                if (file.size > 2 * 1024 * 1024) {
                    alert('Photo file size exceeds 2MB limit.');
                    return null; // Indicate failure
                }
                 // Basic file type check
                 if (!file.type.startsWith('image/')) {
                     alert('Please upload an image file.');
                     return null; // Indicate failure
                 }

                photo = await readFileAsBase64(file);
            } else if (photoInput.files && photoInput.files.length === 0 && id) {
                 // If editing and file input is empty, keep the existing photo.
                 // If you wanted a "remove" option, you'd need a checkbox/button for that.
                 // photo remains the existing photo URL from photoPreview.src
            } else {
                photo = ''; // No photo for new site, or photo was cleared
            }


            // Basic validation
            if (!name || isNaN(lat) || isNaN(lng)) {
                alert('Please fill in Name, Latitude, and Longitude.');
                return null; // Indicate failure
            }

            const siteData = {
                name: name,
                lat: lat,
                lng: lng,
                type: type,
                historicalSignificance: significance,
                duas: duas,
                notes: notes,
                photo: photo,
                visited: visited,
                quran: quran
            };

            // ONLY add the 'id' property if it's an existing site (id is defined).
            // This prevents passing 'id: undefined' to store.add, which can cause issues
            // with autoIncrement in some IndexedDB implementations.
            if (id !== undefined) {
                siteData.id = id;
            }

            return siteData;
        }
        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }


        function openTrailModal(trailData = {}) {
            const isEdit = trailData.id !== undefined;
            document.getElementById('trail-modal-title').textContent = isEdit ? 'Edit Trail' : 'Create New Trail';
            document.getElementById('delete-trail-btn').style.display = isEdit ? 'inline-block' : 'none';

            // Populate form fields
            document.getElementById('trail-id').value = trailData.id || '';
            document.getElementById('trail-name').value = trailData.name || '';
            document.getElementById('trail-description').value = trailData.description || '';

            // Populate site selector checkboxes
            populateTrailSiteSelector(trailData.siteIds || []);

            trailModal.style.display = 'block';
        }

         function getTrailFormData() {
             const id = document.getElementById('trail-id').value ? parseInt(document.getElementById('trail-id').value) : undefined;
             const name = document.getElementById('trail-name').value.trim();
             const description = document.getElementById('trail-description').value.trim();

             const selectedSiteIds = [];
             document.querySelectorAll('#trail-site-selector input[type="checkbox"]:checked').forEach(checkbox => {
                 selectedSiteIds.push(parseInt(checkbox.value));
             });

             // Basic validation
             if (!name) {
                 alert('Please enter a Trail Name.');
                 return null; // Indicate failure
             }

             return {
                 id: id,
                 name: name,
                 description: description,
                 siteIds: selectedSiteIds
             };
         }

         function showConfirm(message) {
             return new Promise((resolve) => {
                 document.getElementById('confirm-message').textContent = message;
                 confirmModal.style.display = 'block';

                 const yesBtn = document.getElementById('confirm-yes');
                 const noBtn = document.getElementById('confirm-no');

                 const handleYes = () => {
                     confirmModal.style.display = 'none';
                     yesBtn.removeEventListener('click', handleYes);
                     noBtn.removeEventListener('click', handleNo);
                     resolve(true);
                 };

                 const handleNo = () => {
                     confirmModal.style.display = 'none';
                     yesBtn.removeEventListener('click', handleYes);
                     noBtn.removeEventListener('click', handleNo);
                     resolve(false);
                 };

                 yesBtn.addEventListener('click', handleYes);
                 noBtn.addEventListener('click', handleNo);
             });
         }


        // --- Data Loading and Display ---

        async function loadAndDisplayData() {
            try {
                allSites = await getAllSitesDB();
                allTrails = await getAllTrailsDB();
                console.log("Data loaded:", { sites: allSites, trails: allTrails });

                refreshMapMarkers();
                renderSiteList(allSites); // Initially render all sites

                refreshMapPolylines();
                renderTrailList(allTrails); // Initially render all trails

                 // Populate site selector for trail creation/editing
                 populateTrailSiteSelector();

            } catch (error) {
                console.error('Failed to load data:', error);
                alert('Failed to load data from local storage.');
            }
        }


        // --- Feature Implementations ---

        // Nominatim Search
        async function searchLocation(query) {
            if (!query) return;
            const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`;

            try {
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'IslamicSitesAtlas/1.0 (Personal App; Yasin Ullah; yasin.ullah@example.com)' // Be polite and identify yourself
                    }
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                if (data && data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lng = parseFloat(result.lon);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        map.setView([lat, lng], 13); // Zoom to result
                        // Optionally add a temporary marker
                        // L.marker([lat, lng]).addTo(map).bindPopup(result.display_name).openPopup();
                    } else {
                         alert('Invalid coordinates received from search.');
                    }
                } else {
                    alert('Location not found.');
                }
            } catch (error) {
                console.error('Error searching location:', error);
                alert('Failed to search location. Please check your internet connection or try again.');
            }
        }

        // My Location
        function findMyLocation() {
            if (!navigator.geolocation) {
                alert('Geolocation is not supported by your browser.');
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    map.setView([lat, lng], 15); // Zoom to user's location
                    // Optionally add a marker for current location
                    // L.marker([lat, lng]).addTo(map).bindPopup("Your Location").openPopup();
                },
                (error) => {
                    console.error('Geolocation error:', error);
                    let message = 'Failed to get your location.';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            message = 'Geolocation permission denied. Please allow location access in your browser settings.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = 'Location information is unavailable.';
                            break;
                        case error.TIMEOUT:
                            message = 'The request to get user location timed out.';
                            break;
                        case error.UNKNOWN_ERROR:
                            message = 'An unknown geolocation error occurred.';
                            break;
                    }
                    alert(message);
                }
            );
        }

        // Backup Data
        async function backupData() {
            try {
                const data = {
                    sites: await getAllSitesDB(),
                    trails: await getAllTrailsDB()
                };
                const jsonString = JSON.stringify(data, null, 2); // Pretty print JSON

                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.-]/g, '');
                a.download = `islamic_sites_atlas_backup_${timestamp}.json`;
                document.body.appendChild(a); // Required for Firefox
                a.click();
                document.body.removeChild(a); // Clean up

                URL.revokeObjectURL(url); // Free up memory
                alert('Data backed up successfully!');
            } catch (error) {
                console.error('Backup failed:', error);
                alert('Failed to backup data. See console for details.');
            }
        }

        // Restore Data
        async function restoreData(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const jsonString = event.target.result;
                    const data = JSON.parse(jsonString);

                    if (!data || !Array.isArray(data.sites) || !Array.isArray(data.trails)) {
                        alert('Invalid backup file format.');
                        return;
                    }

                    const confirmed = await showConfirm('Restoring will permanently delete all your current sites and trails and replace them with the backup data. Are you sure?');

                    if (!confirmed) {
                        console.log('Restore cancelled by user.');
                        return;
                    }

                    console.log('Starting data restore...');
                    const transaction = getObjectStore([SITE_STORE_NAME, TRAIL_STORE_NAME], 'readwrite');
                    const siteStore = transaction.objectStore(SITE_STORE_NAME);
                    const trailStore = transaction.objectStore(TRAIL_STORE_NAME);

                    // Clear existing data
                    await new Promise((resolve, reject) => {
                        const siteClearRequest = siteStore.clear();
                        siteClearRequest.onsuccess = () => {
                            const trailClearRequest = trailStore.clear();
                            trailClearRequest.onsuccess = resolve;
                            trailClearRequest.onerror = reject;
                        };
                        siteClearRequest.onerror = reject;
                    });
                    console.log('Existing data cleared.');

                    // Add new data
                    for (const site of data.sites) {
                         // Remove old ID so IndexedDB assigns a new one
                         delete site.id;
                        await new Promise((resolve, reject) => {
                            const addRequest = siteStore.add(site);
                            addRequest.onsuccess = resolve;
                            addRequest.onerror = reject;
                        });
                    }
                    console.log(`${data.sites.length} sites added.`);

                    for (const trail of data.trails) {
                         // Remove old ID so IndexedDB assigns a new one
                         delete trail.id;
                         // Note: Site IDs in trails will refer to the *new* IDs assigned during site import.
                         // This simple restore assumes the order of sites in the backup matches the order they are re-added.
                         // A more robust approach would involve mapping old IDs to new IDs during import.
                         // For this single-file app, we'll rely on the simple approach.
                        await new Promise((resolve, reject) => {
                            const addRequest = trailStore.add(trail);
                            addRequest.onsuccess = resolve;
                            addRequest.onerror = reject;
                        });
                    }
                     console.log(`${data.trails.length} trails added.`);


                    transaction.oncomplete = async () => {
                         console.log('Data restore complete.');
                         alert('Data restored successfully! The app will now reload.');
                         // Reload data and UI
                         await loadAndDisplayData();
                    };
                    transaction.onerror = (event) => {
                         console.error('Error during restore transaction:', event.target.error);
                         alert('An error occurred during data restore.');
                    };

                } catch (error) {
                    console.error('Restore failed:', error);
                    alert('Failed to restore data. Invalid file or format.');
                }
            };
            reader.onerror = (error) => {
                console.error('Error reading file:', error);
                alert('Failed to read the backup file.');
            };
            reader.readAsText(file);
        }


        // --- Event Listeners ---

        document.getElementById('save-site-btn').addEventListener('click', async () => {
            const siteData = await getSiteFormData();
            if (siteData) {
                try {
                    const siteId = await saveSiteDB(siteData);
                    siteData.id = siteId; // Ensure the object has the ID if it was new
                    // Update or add site in cached array
                    const existingIndex = allSites.findIndex(s => s.id === siteId);
                    if (existingIndex > -1) {
                        allSites[existingIndex] = siteData;
                    } else {
                        allSites.push(siteData);
                    }
                    console.log('Site saved:', siteData);
                    refreshMapMarkers();
                    renderSiteList(allSites); // Re-render list (filters will apply)
                    populateTrailSiteSelector(); // Update trail site options
                    siteModal.style.display = 'none';
                } catch (error) {
                    console.error('Error saving site:', error);
                    alert('Failed to save site.');
                }
            }
        });

        document.getElementById('delete-site-btn').addEventListener('click', async () => {
            const siteId = parseInt(document.getElementById('site-id').value);
            if (siteId) {
                 const confirmed = await showConfirm('Are you sure you want to delete this site? This cannot be undone.');
                 if (!confirmed) return;

                try {
                    await deleteSiteDB(siteId);
                    // Remove from cached array
                    allSites = allSites.filter(site => site.id !== siteId);
                     // Also update cached trails as the site was removed from them in deleteSiteDB
                     allTrails = allTrails.map(trail => ({
                         ...trail,
                         siteIds: trail.siteIds.filter(id => id !== siteId)
                     }));

                    console.log('Site deleted:', siteId);
                    removeSiteFromMap(siteId);
                    refreshMapPolylines(); // Trails might change
                    renderSiteList(allSites); // Re-render list
                    renderTrailList(allTrails); // Re-render trail list
                    populateTrailSiteSelector(); // Update trail site options
                    siteModal.style.display = 'none';
                } catch (error) {
                    console.error('Error deleting site:', error);
                    alert('Failed to delete site.');
                }
            }
        });


         document.getElementById('add-trail-btn').addEventListener('click', () => {
             openTrailModal({}); // Open modal for new trail
         });

         document.getElementById('save-trail-btn').addEventListener('click', async () => {
             const trailData = getTrailFormData();
             if (trailData) {
                 try {
                     const trailId = await saveTrailDB(trailData);
                     trailData.id = trailId; // Ensure the object has the ID if it was new

                     // Update or add trail in cached array
                     const existingIndex = allTrails.findIndex(t => t.id === trailId);
                     if (existingIndex > -1) {
                         allTrails[existingIndex] = trailData;
                     } else {
                         allTrails.push(trailData);
                     }
                     console.log('Trail saved:', trailData);
                     refreshMapPolylines();
                     renderTrailList(allTrails); // Re-render list
                     trailModal.style.display = 'none';
                 } catch (error) {
                     console.error('Error saving trail:', error);
                     alert('Failed to save trail.');
                 }
             }
         });

         document.getElementById('delete-trail-btn').addEventListener('click', async () => {
             const trailId = parseInt(document.getElementById('trail-id').value);
             if (trailId) {
                 const confirmed = await showConfirm('Are you sure you want to delete this trail? This cannot be undone.');
                 if (!confirmed) return;

                 try {
                     await deleteTrailDB(trailId);
                     // Remove from cached array
                     allTrails = allTrails.filter(trail => trail.id !== trailId);
                     console.log('Trail deleted:', trailId);
                     removeTrailFromMap(trailId);
                     renderTrailList(allTrails); // Re-render list
                     trailModal.style.display = 'none';
                 } catch (error) {
                     console.error('Error deleting trail:', error);
                     alert('Failed to delete trail.');
                 }
             }
         });


        // Filter Event Listeners
        document.getElementById('filter-type').addEventListener('change', applyFilters);
        document.getElementById('filter-visited').addEventListener('change', applyFilters);
        document.getElementById('site-search').addEventListener('input', applyFilters); // Use input for live search

        // Apply filters function (called by filter event listeners)
        function applyFilters() {
             const filterType = document.getElementById('filter-type').value;
             const filterVisited = document.getElementById('filter-visited').value;
             const searchTerm = document.getElementById('site-search').value.toLowerCase();

             const filteredSites = allSites.filter(site => {
                 const typeMatch = filterType === '' || site.type === filterType;
                 const visitedMatch = filterVisited === '' || String(site.visited) === filterVisited;
                 const searchMatch = searchTerm === '' ||
                                     (site.name && site.name.toLowerCase().includes(searchTerm)) ||
                                     (site.notes && site.notes.toLowerCase().includes(searchTerm)) ||
                                     (site.historicalSignificance && site.historicalSignificance.toLowerCase().includes(searchTerm)) ||
                                     (site.duas && site.duas.toLowerCase().includes(searchTerm)) ||
                                     (site.quran && site.quran.toLowerCase().includes(searchTerm));
                 return typeMatch && visitedMatch && searchMatch;
             });

             // Update map markers based on filter
             refreshMapMarkers(); // This function already applies the filter internally

             // Update site list based on filter
             renderSiteList(filteredSites);
         }


        // Nominatim Search Button
        document.getElementById('search-location-btn').addEventListener('click', () => {
            const query = document.getElementById('nominatim-search').value;
            searchLocation(query);
        });
         // Allow pressing Enter in search box
         document.getElementById('nominatim-search').addEventListener('keypress', function(event) {
             if (event.key === 'Enter') {
                 event.preventDefault(); // Prevent form submission if it were in a form
                 document.getElementById('search-location-btn').click();
             }
         });


        // My Location Button
        document.getElementById('my-location-btn').addEventListener('click', findMyLocation);

        // Backup/Restore Buttons
        document.getElementById('backup-data-btn').addEventListener('click', backupData);
        document.getElementById('restore-data-btn').addEventListener('click', () => {
             document.getElementById('restore-file-input').click(); // Trigger file picker
        });
        document.getElementById('restore-file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                restoreData(file);
            }
            // Clear the file input value so the same file can be selected again if needed
            event.target.value = '';
        });


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            initMap();
            await openDB(); // Open database first
            await loadAndDisplayData(); // Then load and display data
        });

    </script>
</body>
</html>