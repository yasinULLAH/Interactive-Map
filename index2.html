<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Islamic Sites Atlas (MyData) - Yasin Ullah</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <style>
        :root {
            --primary-bg: #0a0f1f; /* Deep dark blue */
            --secondary-bg: #1a1f36; /* Slightly lighter dark blue */
            --tertiary-bg: #2a2f4d; /* For cards, modals */
            --accent-color: #00f0ff; /* Glowing cyan */
            --accent-hover: #00ffff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0b0;
            --border-color: #007080; /* Dark cyan for borders */
            --success-color: #2ecc71;
            --error-color: #e74c3c;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-futuristic: 'Orbitron', sans-serif; /* Optional, if available or imported */
        }

        /* Basic Reset & Global Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; overflow: hidden; font-family: var(--font-main); background-color: var(--primary-bg); color: var(--text-color); }
        
        /* Layout */
        #app-container { display: flex; flex-direction: column; height: 100%; }
        header { background-color: var(--secondary-bg); padding: 10px 15px; text-align: center; border-bottom: 1px solid var(--border-color); z-index: 1001;}
        header h1 { font-size: 1.5em; color: var(--accent-color); text-shadow: 0 0 5px var(--accent-color); font-family: var(--font-futuristic, var(--font-main)); }
        header p { font-size: 0.8em; color: var(--text-muted); }
        
        #toolbar { display: flex; flex-wrap: wrap; gap: 5px; padding: 8px; background-color: var(--secondary-bg); border-bottom: 1px solid var(--border-color); z-index: 1000; }
        #toolbar button, #toolbar input[type="search"], #toolbar select {
            padding: 8px 12px; background-color: var(--tertiary-bg); color: var(--accent-color); border: 1px solid var(--border-color);
            border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: background-color 0.3s, box-shadow 0.3s;
        }
        #toolbar button:hover, #toolbar select:hover { background-color: var(--primary-bg); box-shadow: 0 0 8px var(--accent-hover); }
        #toolbar input[type="search"] { flex-grow: 1; min-width: 150px; }

        #main-content { flex-grow: 1; display: flex; position: relative; }
        #map { width: 100%; height: 100%; background-color: #05080f; }
        .leaflet-tile-pane { filter: grayscale(0.3) brightness(0.8) contrast(1.1); } /* Subtle dark theme for tiles */

        /* Sidebar for Lists/Filters */
        #sidebar {
            position: absolute; top: 0; right: -350px; /* Initially hidden */
            width: 300px; max-width: 80vw; height: 100%; background-color: rgba(26, 31, 54, 0.95); /* var(--secondary-bg) with alpha */
            backdrop-filter: blur(5px);
            border-left: 1px solid var(--border-color);
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            transition: right 0.3s ease-in-out;
            z-index: 999;
            display: flex; flex-direction: column;
            overflow-y: auto;
        }
        #sidebar.open { right: 0; }
        #sidebar-toggle { position: fixed; top: 120px; right: 10px; z-index: 1000; background: var(--accent-color); color: var(--primary-bg); border:none; border-radius:5px; padding:10px; cursor:pointer; box-shadow: 0 0 10px var(--accent-color); }
        #sidebar-toggle.on-sidebar { right: 310px; } /* Adjust if sidebar width changes */

        .sidebar-section { padding: 15px; border-bottom: 1px solid var(--border-color); }
        .sidebar-section h3 { color: var(--accent-color); margin-bottom: 10px; font-size: 1.1em; }
        .sidebar-section ul { list-style: none; padding: 0; }
        .sidebar-section li { padding: 8px 5px; margin-bottom: 5px; background-color: var(--tertiary-bg); border-radius: 3px; cursor: pointer; transition: background-color 0.2s; font-size: 0.9em; }
        .sidebar-section li:hover { background-color: var(--primary-bg); }
        .sidebar-section li.active-trail-site { background-color: var(--accent-color); color: var(--primary-bg); }

        /* Modals */
        .modal {
            display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.7); backdrop-filter: blur(3px);
            align-items: center; justify-content: center; display: none; /* flex after display:flex */
        }
        .modal-content {
            background-color: var(--secondary-bg); color: var(--text-color);
            margin: auto; padding: 20px; border: 1px solid var(--border-color); border-radius: 8px;
            width: 90%; max-width: 600px;
            box-shadow: 0 0 20px var(--accent-color);
            max-height: 90vh; overflow-y: auto;
        }
        .modal-content h2 { color: var(--accent-color); margin-bottom: 15px; }
        .modal-content label { display: block; margin-top: 10px; margin-bottom: 5px; color: var(--text-muted); }
        .modal-content input[type="text"], .modal-content input[type="number"], .modal-content textarea, .modal-content select {
            width: 100%; padding: 10px; margin-bottom: 10px; background-color: var(--primary-bg);
            border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-color);
        }
        .modal-content textarea { min-height: 80px; resize: vertical; }
        .modal-content input[type="checkbox"] { margin-right: 5px; vertical-align: middle; }
        .modal-content .form-actions { margin-top: 20px; text-align: right; }
        .modal-content button {
            padding: 10px 15px; margin-left: 10px; background-color: var(--accent-color); color: var(--primary-bg);
            border: none; border-radius: 4px; cursor: pointer; font-weight: bold;
        }
        .modal-content button.cancel-btn { background-color: var(--text-muted); color: var(--primary-bg); }
        .modal-content button.delete-btn { background-color: var(--error-color); color: white; }
        .modal-content img#photoPreview { max-width: 100%; max-height: 200px; margin-top: 10px; border-radius: 4px; border: 1px solid var(--border-color); }

        /* Custom Markers */
        .custom-leaflet-icon { background: transparent; border: none; } /* Base for DivIcon */
        .marker-base {
            width: 28px; height: 28px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: bold; color: white;
            border: 2px solid white;
            text-shadow: 0 0 3px black;
            position: relative;
        }
        .marker-base::after { /* Pulse animation */
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 100%; height: 100%;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(1);
            animation: pulse 2s infinite;
            z-index: -1;
            box-shadow: 0 0 0 0 rgba(0,0,0,0.1); /* Base for animation */
        }
        .marker-visited .marker-base { border-color: var(--success-color); } /* Visited indicator */
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.9); box-shadow: 0 0 0 0px rgba(255,255,255, 0.5); }
            70% { transform: translate(-50%, -50%) scale(1.5); box-shadow: 0 0 0 15px rgba(255,255,255, 0); }
            100% { transform: translate(-50%, -50%) scale(0.9); box-shadow: 0 0 0 0px rgba(255,255,255, 0); }
        }
        /* Type-specific colors (applied via JS) */
        .marker-Masjid .marker-base { background-color: #27ae60; box-shadow: 0 0 12px #2ecc71; }
        .marker-Masjid .marker-base::after { animation-name: pulse-green; }
        .marker-Tomb .marker-base, .marker-Dargah .marker-base { background-color: #2980b9; box-shadow: 0 0 12px #3498db; }
        .marker-Tomb .marker-base::after, .marker-Dargah .marker-base::after { animation-name: pulse-blue; }
        .marker-Khanqah .marker-base { background-color: #8e44ad; box-shadow: 0 0 12px #9b59b6; }
        .marker-Khanqah .marker-base::after { animation-name: pulse-purple; }
        .marker-Historical_Site .marker-base { background-color: #f39c12; box-shadow: 0 0 12px #e67e22; }
        .marker-Historical_Site .marker-base::after { animation-name: pulse-orange; }
        .marker-Other .marker-base { background-color: #7f8c8d; box-shadow: 0 0 12px #95a5a6; }
        .marker-Other .marker-base::after { animation-name: pulse-grey; }

        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0px rgba(46, 204, 113, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0px rgba(46, 204, 113, 0); } }
        @keyframes pulse-blue { 0% { box-shadow: 0 0 0 0px rgba(52, 152, 219, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(52, 152, 219, 0); } 100% { box-shadow: 0 0 0 0px rgba(52, 152, 219, 0); } }
        @keyframes pulse-purple { 0% { box-shadow: 0 0 0 0px rgba(155, 89, 182, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(155, 89, 182, 0); } 100% { box-shadow: 0 0 0 0px rgba(155, 89, 182, 0); } }
        @keyframes pulse-orange { 0% { box-shadow: 0 0 0 0px rgba(243, 156, 18, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(243, 156, 18, 0); } 100% { box-shadow: 0 0 0 0px rgba(243, 156, 18, 0); } }
        @keyframes pulse-grey { 0% { box-shadow: 0 0 0 0px rgba(127, 140, 141, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(127, 140, 141, 0); } 100% { box-shadow: 0 0 0 0px rgba(127, 140, 141, 0); } }

        /* Leaflet Popup Customization */
        .leaflet-popup-content-wrapper { background-color: var(--tertiary-bg); color: var(--text-color); border-radius: 5px; box-shadow: 0 0 10px var(--accent-color); border: 1px solid var(--border-color);}
        .leaflet-popup-content { font-size: 0.9em; }
        .leaflet-popup-tip { background: var(--tertiary-bg); }
        .leaflet-popup-content h4 { color: var(--accent-color); margin-bottom: 5px; }
        .leaflet-popup-content p { margin: 3px 0; }
        .leaflet-popup-content button { padding: 5px 8px; font-size: 0.8em; margin-top: 5px; margin-right: 5px; background-color: var(--accent-color); color: var(--primary-bg); border:none; border-radius: 3px; }
        .leaflet-popup-content button.delete { background-color: var(--error-color); color: white; }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8); z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5em; color: var(--accent-color); text-shadow: 0 0 10px var(--accent-color);
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            header h1 { font-size: 1.2em; }
            #toolbar { flex-direction: column; }
            #toolbar input[type="search"] { width: 100%; }
            .modal-content { width: 95%; padding: 15px; }
            #sidebar { width: 250px; }
            #sidebar-toggle.on-sidebar { right: 260px; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--primary-bg); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-color); }

    </style>
</head>
<body>
    <div id="app-container">
        <header>
            <h1>Islamic Sites Atlas (MyData)</h1>
            <p>By Yasin Ullah, Pakistani</p>
        </header>

        <div id="toolbar">
            <button id="addSiteBtn">Add New Site</button>
            <button id="createTrailBtn">Create Trail</button>
            <button id="myLocationBtn">My Location</button>
            <input type="search" id="nominatimSearchInput" placeholder="Search map (e.g., city, country)">
            <button id="nominatimSearchBtn">Search Map</button>
            <select id="filterType">
                <option value="">All Types</option>
                <option value="Masjid">Masjid</option>
                <option value="Tomb">Tomb</option>
                <option value="Dargah">Dargah</option>
                <option value="Khanqah">Khanqah</option>
                <option value="Historical Site">Historical Site</option>
                <option value="Other">Other</option>
            </select>
            <select id="filterVisited">
                <option value="">All Visited Status</option>
                <option value="true">Visited</option>
                <option value="false">Not Visited</option>
            </select>
            <input type="search" id="localSearchInput" placeholder="Search my sites...">
            <button id="backupBtn">Backup Data</button>
            <input type="file" id="restoreFile" accept=".json" style="display: none;">
            <button id="restoreBtn">Restore Data</button>
        </div>

        <main id="main-content">
            <div id="map"></div>
            <button id="sidebar-toggle">☰</button>
            <div id="sidebar">
                <div class="sidebar-section">
                    <h3>Sites</h3>
                    <ul id="sites-list-sidebar"></ul>
                </div>
                <div class="sidebar-section">
                    <h3>Trails</h3>
                    <ul id="trails-list-sidebar"></ul>
                </div>
            </div>
        </main>
    </div>

    <!-- Site Form Modal -->
    <div id="site-form-modal" class="modal">
        <div class="modal-content">
            <h2 id="site-form-title">Add New Site</h2>
            <form id="siteForm">
                <input type="hidden" id="siteId">
                <label for="siteName">Name:</label>
                <input type="text" id="siteName" required>
                
                <label for="siteLat">Latitude:</label>
                <input type="number" id="siteLat" step="any" required>
                
                <label for="siteLng">Longitude:</label>
                <input type="number" id="siteLng" step="any" required>

                <label for="siteType">Type:</label>
                <select id="siteType">
                    <option value="Masjid">Masjid</option>
                    <option value="Tomb">Tomb</option>
                    <option value="Dargah">Dargah</option>
                    <option value="Khanqah">Khanqah</option>
                    <option value="Historical Site">Historical Site</option>
                    <option value="Other">Other</option>
                </select>

                <label for="siteHistoricalSignificance">Historical Significance:</label>
                <textarea id="siteHistoricalSignificance"></textarea>

                <label for="siteRelatedDuasPractices">Related Duas/Practices:</label>
                <textarea id="siteRelatedDuasPractices"></textarea>

                <label for="sitePersonalVisitNotes">Personal Visit Notes:</label>
                <textarea id="sitePersonalVisitNotes"></textarea>

                <label for="siteRelatedQuranHadith">Related Quran/Hadith Snippets:</label>
                <textarea id="siteRelatedQuranHadith"></textarea>

                <label for="sitePhoto">Photo:</label>
                <input type="file" id="sitePhotoInput" accept="image/*">
                <img id="photoPreview" src="#" alt="Photo Preview" style="display:none;">
                <input type="hidden" id="sitePhotoData"> <!-- Store base64 data -->

                <label>
                    <input type="checkbox" id="siteVisitedStatus"> Visited
                </label>

                <div class="form-actions">
                    <button type="button" class="cancel-btn" id="cancelSiteForm">Cancel</button>
                    <button type="submit">Save Site</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Trail Form Modal -->
    <div id="trail-form-modal" class="modal">
        <div class="modal-content">
            <h2 id="trail-form-title">Create New Trail</h2>
            <form id="trailForm">
                <input type="hidden" id="trailId">
                <label for="trailName">Trail Name:</label>
                <input type="text" id="trailName" required>
                <label for="trailDescription">Description:</label>
                <textarea id="trailDescription"></textarea>
                <label>Select Sites for Trail (Ctrl/Cmd + Click for multiple):</label>
                <select id="trailSitesSelect" multiple style="min-height: 150px;"></select>
                <div class="form-actions">
                    <button type="button" class="cancel-btn" id="cancelTrailForm">Cancel</button>
                    <button type="submit">Save Trail</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Confirm Dialog Modal -->
    <div id="confirm-dialog" class="modal">
        <div class="modal-content">
            <h2 id="confirm-title">Confirm</h2>
            <p id="confirm-message"></p>
            <div class="form-actions">
                <button type="button" class="cancel-btn" id="confirm-cancel-btn">Cancel</button>
                <button type="button" id="confirm-ok-btn">OK</button>
            </div>
        </div>
    </div>

    <div id="loading-overlay" style="display:none;">Loading...</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
    // --- Constants and Config ---
    const DB_NAME = 'IslamicSitesAtlasDB_YasinUllah';
    const DB_VERSION = 1;
    const SITES_STORE_NAME = 'sites';
    const TRAILS_STORE_NAME = 'trails';

    // --- Global State ---
    let db;
    let map;
    let currentMarkers = {}; // { siteId: leafletMarker }
    let currentTrailPolylines = {}; // { trailId: leafletPolyline }
    let sitesDataCache = {}; // { siteId: siteObject }
    let trailsDataCache = {}; // { trailId: trailObject }
    let currentlyEditingSiteId = null;
    let currentlyEditingTrailId = null;
    let confirmCallback = null;

    // --- DOM Elements ---
    const loadingOverlay = document.getElementById('loading-overlay');
    const siteFormModal = document.getElementById('site-form-modal');
    const trailFormModal = document.getElementById('trail-form-modal');
    const confirmDialog = document.getElementById('confirm-dialog');
    const siteForm = document.getElementById('siteForm');
    const trailForm = document.getElementById('trailForm');
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebar-toggle');

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', initApp);

    function initApp() {
        showLoading("Initializing Atlas...");
        initDB().then(() => {
            initMap();
            loadAllDataFromDB();
            setupEventListeners();
            hideLoading();
        }).catch(err => {
            console.error("App initialization failed:", err);
            alert("Error initializing application. Please try refreshing. " + err.message);
            hideLoading();
        });
    }

    function showLoading(message = "Loading...") {
        loadingOverlay.textContent = message;
        loadingOverlay.style.display = 'flex';
    }
    function hideLoading() {
        loadingOverlay.style.display = 'none';
    }

    // --- IndexedDB ---
    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = (event) => reject("Database error: " + event.target.errorCode);
            request.onsuccess = (event) => {
                db = event.target.result;
                resolve(db);
            };
            request.onupgradeneeded = (event) => {
                let storeDb = event.target.result;
                if (!storeDb.objectStoreNames.contains(SITES_STORE_NAME)) {
                    const sitesStore = storeDb.createObjectStore(SITES_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    sitesStore.createIndex('name', 'name', { unique: false });
                    sitesStore.createIndex('type', 'type', { unique: false });
                    sitesStore.createIndex('visitedStatus', 'visitedStatus', { unique: false });
                }
                if (!storeDb.objectStoreNames.contains(TRAILS_STORE_NAME)) {
                    const trailsStore = storeDb.createObjectStore(TRAILS_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    trailsStore.createIndex('name', 'name', { unique: false });
                }
            };
        });
    }

    function dbTransaction(storeName, mode, callback) {
        return new Promise((resolve, reject) => {
            if (!db) {
                reject("Database not initialized.");
                return;
            }
            const transaction = db.transaction(storeName, mode);
            const store = transaction.objectStore(storeName);
            callback(store, resolve, reject, transaction);
            transaction.onerror = (event) => reject("Transaction error: " + event.target.error);
        });
    }
    
    function getAllFromStore(storeName) {
        return dbTransaction(storeName, 'readonly', (store, resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject("Error fetching all from " + storeName + ": " + event.target.error);
        });
    }

    function addToStore(storeName, data) {
        return dbTransaction(storeName, 'readwrite', (store, resolve, reject) => {
            const request = store.add(data);
            request.onsuccess = () => resolve(request.result); // Returns the new key
            request.onerror = (event) => reject("Error adding to " + storeName + ": " + event.target.error);
        });
    }

    function updateInStore(storeName, data) {
        return dbTransaction(storeName, 'readwrite', (store, resolve, reject) => {
            const request = store.put(data);
            request.onsuccess = () => resolve(request.result); // Returns the key
            request.onerror = (event) => reject("Error updating in " + storeName + ": " + event.target.error);
        });
    }

    function deleteFromStore(storeName, id) {
        return dbTransaction(storeName, 'readwrite', (store, resolve, reject) => {
            const request = store.delete(id);
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject("Error deleting from " + storeName + ": " + event.target.error);
        });
    }
    
    function clearStore(storeName) {
        return dbTransaction(storeName, 'readwrite', (store, resolve, reject) => {
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject("Error clearing store " + storeName + ": " + event.target.error);
        });
    }

    // --- Map Logic ---
    function initMap() {
        map = L.map('map').setView([29.9457, 69.3451], 5); // Centered on Pakistan
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors. App by Yasin Ullah.'
        }).addTo(map);

        map.on('click', (e) => {
            if (siteFormModal.style.display === 'flex' && !document.getElementById('siteId').value) { // Only if adding new and form is open
                document.getElementById('siteLat').value = e.latlng.lat.toFixed(6);
                document.getElementById('siteLng').value = e.latlng.lng.toFixed(6);
            } else {
                 // Optionally: show coordinates or offer to add new site here
            }
        });
    }

    function createCustomIcon(site) {
        const typeClass = `marker-${site.type.replace(/\s+/g, '_')}`; // e.g., marker-Historical_Site
        const visitedClass = site.visitedStatus ? 'marker-visited' : '';
        const symbol = site.type.charAt(0).toUpperCase();

        return L.divIcon({
            className: `custom-leaflet-icon ${typeClass} ${visitedClass}`,
            html: `<div class="marker-base">${symbol}</div>`,
            iconSize: [28, 28],
            iconAnchor: [14, 14], // Center of the icon
            popupAnchor: [0, -14]
        });
    }

    function addMarkerToMap(site) {
        if (currentMarkers[site.id]) map.removeLayer(currentMarkers[site.id]);
        
        const icon = createCustomIcon(site);
        const marker = L.marker([site.lat, site.lng], { icon: icon, draggable: true })
            .addTo(map)
            .bindPopup(createPopupContent(site));

        marker.on('dragend', (event) => {
            const newCoords = event.target.getLatLng();
            site.lat = parseFloat(newCoords.lat.toFixed(6));
            site.lng = parseFloat(newCoords.lng.toFixed(6));
            updateSite(site); // This will also re-render, but dragend is direct
        });
        
        currentMarkers[site.id] = marker;
    }
    
    function createPopupContent(site) {
        let content = `<h4>${site.name}</h4>
                       <p><strong>Type:</strong> ${site.type}</p>
                       <p><strong>Visited:</strong> ${site.visitedStatus ? 'Yes' : 'No'}</p>`;
        if (site.historicalSignificance) content += `<p><strong>Significance:</strong> ${site.historicalSignificance.substring(0,50)}...</p>`;
        content += `<button onclick="openSiteFormForEdit(${site.id})">Edit</button>
                    <button class="delete" onclick="confirmDeleteSite(${site.id})">Delete</button>
                    <button onclick="viewSiteDetails(${site.id})">Details</button>`; // A new view details function might be good
        return content;
    }
    window.viewSiteDetails = (siteId) => { // Make it global for popup
        const site = sitesDataCache[siteId];
        if (!site) return;
        let detailsHtml = `<h2>${site.name}</h2>
            <p><strong>Coordinates:</strong> ${site.lat}, ${site.lng}</p>
            <p><strong>Type:</strong> ${site.type}</p>
            <p><strong>Visited:</strong> ${site.visitedStatus ? 'Yes' : 'No'}</p>
            ${site.historicalSignificance ? `<p><strong>Historical Significance:</strong><br>${site.historicalSignificance.replace(/\n/g, '<br>')}</p>` : ''}
            ${site.relatedDuasPractices ? `<p><strong>Related Duas/Practices:</strong><br>${site.relatedDuasPractices.replace(/\n/g, '<br>')}</p>` : ''}
            ${site.personalVisitNotes ? `<p><strong>Personal Notes:</strong><br>${site.personalVisitNotes.replace(/\n/g, '<br>')}</p>` : ''}
            ${site.relatedQuranHadith ? `<p><strong>Quran/Hadith Snippets:</strong><br>${site.relatedQuranHadith.replace(/\n/g, '<br>')}</p>` : ''}
            ${site.photoData ? `<p><strong>Photo:</strong><br><img src="${site.photoData}" style="max-width:100%; max-height:300px;"></p>` : ''}
            <div class="form-actions"><button onclick="closeConfirmDialog()">Close</button></div>`; // Use confirm dialog as a generic modal viewer
        
        document.getElementById('confirm-title').textContent = "Site Details";
        document.getElementById('confirm-message').innerHTML = detailsHtml;
        document.getElementById('confirm-cancel-btn').style.display = 'none';
        document.getElementById('confirm-ok-btn').style.display = 'none'; // Hide default buttons or repurpose one
        // A dedicated detail modal would be cleaner, but this reuses confirm-dialog
        const closeButton = document.createElement('button');
        closeButton.textContent = "Close";
        closeButton.onclick = () => {
            closeConfirmDialog();
            // Restore confirm dialog buttons if they were hidden
            document.getElementById('confirm-cancel-btn').style.display = 'inline-block';
            document.getElementById('confirm-ok-btn').style.display = 'inline-block';
        };
        // Clear previous custom buttons if any
        const formActions = confirmDialog.querySelector('.form-actions');
        while (formActions.firstChild) { formActions.removeChild(formActions.firstChild); }
        formActions.appendChild(closeButton);

        confirmDialog.style.display = 'flex';
    };


    function addPolylineToMap(trail) {
        if (currentTrailPolylines[trail.id]) map.removeLayer(currentTrailPolylines[trail.id]);
        
        const latlngs = trail.siteIds
            .map(siteId => sitesDataCache[siteId])
            .filter(site => site) // Ensure site exists
            .map(site => [site.lat, site.lng]);

        if (latlngs.length < 2) return; // Need at least two points for a polyline

        const polyline = L.polyline(latlngs, { color: varToCss('--accent-color'), weight: 3, opacity: 0.7, dashArray: '5, 5' })
            .addTo(map)
            .bindPopup(`<h4>${trail.name}</h4><p>${trail.description || 'No description'}</p><button onclick="openTrailFormForEdit(${trail.id})">Edit</button><button class="delete" onclick="confirmDeleteTrail(${trail.id})">Delete</button>`);
        currentTrailPolylines[trail.id] = polyline;
    }
    
    function varToCss(varName) { // Helper to get CSS var value for Leaflet options
        return getComputedStyle(document.documentElement).getPropertyValue(varName.substring(4, varName.length-1)).trim();
    }

    // --- UI Rendering & Forms ---
    function openModal(modalElement) { modalElement.style.display = 'flex'; }
    function closeModal(modalElement) { modalElement.style.display = 'none'; }

    function openSiteFormForAdd(coords = null) {
        currentlyEditingSiteId = null;
        siteForm.reset();
        document.getElementById('site-form-title').textContent = 'Add New Site';
        document.getElementById('siteId').value = '';
        document.getElementById('photoPreview').style.display = 'none';
        document.getElementById('photoPreview').src = '#';
        document.getElementById('sitePhotoData').value = '';
        if (coords) {
            document.getElementById('siteLat').value = coords.lat.toFixed(6);
            document.getElementById('siteLng').value = coords.lng.toFixed(6);
        }
        openModal(siteFormModal);
    }
    
    window.openSiteFormForEdit = (id) => { // Make it global for popup
        currentlyEditingSiteId = id;
        const site = sitesDataCache[id];
        if (!site) return;
        document.getElementById('site-form-title').textContent = 'Edit Site';
        document.getElementById('siteId').value = site.id;
        document.getElementById('siteName').value = site.name;
        document.getElementById('siteLat').value = site.lat;
        document.getElementById('siteLng').value = site.lng;
        document.getElementById('siteType').value = site.type;
        document.getElementById('siteHistoricalSignificance').value = site.historicalSignificance || '';
        document.getElementById('siteRelatedDuasPractices').value = site.relatedDuasPractices || '';
        document.getElementById('sitePersonalVisitNotes').value = site.personalVisitNotes || '';
        document.getElementById('siteRelatedQuranHadith').value = site.relatedQuranHadith || '';
        document.getElementById('siteVisitedStatus').checked = site.visitedStatus;
        document.getElementById('sitePhotoData').value = site.photoData || '';
        if (site.photoData) {
            document.getElementById('photoPreview').src = site.photoData;
            document.getElementById('photoPreview').style.display = 'block';
        } else {
            document.getElementById('photoPreview').style.display = 'none';
            document.getElementById('photoPreview').src = '#';
        }
        openModal(siteFormModal);
    };

    siteForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        showLoading("Saving site...");
        const siteData = {
            name: document.getElementById('siteName').value,
            lat: parseFloat(document.getElementById('siteLat').value),
            lng: parseFloat(document.getElementById('siteLng').value),
            type: document.getElementById('siteType').value,
            historicalSignificance: document.getElementById('siteHistoricalSignificance').value,
            relatedDuasPractices: document.getElementById('siteRelatedDuasPractices').value,
            personalVisitNotes: document.getElementById('sitePersonalVisitNotes').value,
            relatedQuranHadith: document.getElementById('siteRelatedQuranHadith').value,
            visitedStatus: document.getElementById('siteVisitedStatus').checked,
            photoData: document.getElementById('sitePhotoData').value,
        };

        try {
            if (currentlyEditingSiteId) {
                siteData.id = currentlyEditingSiteId;
                await updateSite(siteData);
            } else {
                await addSite(siteData);
            }
            closeModal(siteFormModal);
        } catch (err) {
            console.error("Error saving site:", err);
            alert("Failed to save site: " + err.message);
        } finally {
            hideLoading();
        }
    });
    
    document.getElementById('sitePhotoInput').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('photoPreview').src = e.target.result;
                document.getElementById('photoPreview').style.display = 'block';
                document.getElementById('sitePhotoData').value = e.target.result;
            };
            reader.readAsDataURL(file);
        } else {
            document.getElementById('photoPreview').style.display = 'none';
            document.getElementById('photoPreview').src = '#';
            document.getElementById('sitePhotoData').value = ''; // Clear if no file selected
        }
    });


    document.getElementById('cancelSiteForm').addEventListener('click', () => closeModal(siteFormModal));

    function openTrailForm(trail = null) {
        currentlyEditingTrailId = trail ? trail.id : null;
        trailForm.reset();
        document.getElementById('trail-form-title').textContent = trail ? 'Edit Trail' : 'Create New Trail';
        document.getElementById('trailId').value = trail ? trail.id : '';
        
        const sitesSelect = document.getElementById('trailSitesSelect');
        sitesSelect.innerHTML = ''; // Clear previous options
        Object.values(sitesDataCache).forEach(site => {
            const option = document.createElement('option');
            option.value = site.id;
            option.textContent = site.name;
            if (trail && trail.siteIds.includes(site.id)) {
                option.selected = true;
            }
            sitesSelect.appendChild(option);
        });

        if (trail) {
            document.getElementById('trailName').value = trail.name;
            document.getElementById('trailDescription').value = trail.description || '';
        }
        openModal(trailFormModal);
    }
    window.openTrailFormForEdit = (id) => { // Global for popup
        const trail = trailsDataCache[id];
        if (trail) openTrailForm(trail);
    };

    trailForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        showLoading("Saving trail...");
        const selectedOptions = Array.from(document.getElementById('trailSitesSelect').selectedOptions);
        const trailData = {
            name: document.getElementById('trailName').value,
            description: document.getElementById('trailDescription').value,
            siteIds: selectedOptions.map(opt => parseInt(opt.value))
        };

        try {
            if (currentlyEditingTrailId) {
                trailData.id = currentlyEditingTrailId;
                await updateTrail(trailData);
            } else {
                await addTrail(trailData);
            }
            closeModal(trailFormModal);
        } catch (err) {
            console.error("Error saving trail:", err);
            alert("Failed to save trail: " + err.message);
        } finally {
            hideLoading();
        }
    });
    document.getElementById('cancelTrailForm').addEventListener('click', () => closeModal(trailFormModal));

    function showConfirmDialog(title, message, callback) {
        document.getElementById('confirm-title').textContent = title;
        document.getElementById('confirm-message').innerHTML = message; // Use innerHTML for potential formatting
        confirmCallback = callback;
        openModal(confirmDialog);
        // Ensure default buttons are visible
        document.getElementById('confirm-cancel-btn').style.display = 'inline-block';
        document.getElementById('confirm-ok-btn').style.display = 'inline-block';
        // Clear any custom buttons from viewSiteDetails
        const formActions = confirmDialog.querySelector('.form-actions');
        if (formActions.children.length > 2) { // If more than cancel/ok
            while (formActions.firstChild) { formActions.removeChild(formActions.firstChild); }
            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'cancel-btn';
            cancelBtn.id = 'confirm-cancel-btn';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => { if (confirmCallback) confirmCallback(false); closeModal(confirmDialog); };
            
            const okBtn = document.createElement('button');
            okBtn.type = 'button';
            okBtn.id = 'confirm-ok-btn';
            okBtn.textContent = 'OK';
            okBtn.onclick = () => { if (confirmCallback) confirmCallback(true); closeModal(confirmDialog); };

            formActions.appendChild(cancelBtn);
            formActions.appendChild(okBtn);
        }
    }
    function closeConfirmDialog() {
        closeModal(confirmDialog);
    }
    document.getElementById('confirm-ok-btn').addEventListener('click', () => {
        if (confirmCallback) confirmCallback(true);
        closeModal(confirmDialog);
    });
    document.getElementById('confirm-cancel-btn').addEventListener('click', () => {
        if (confirmCallback) confirmCallback(false);
        closeModal(confirmDialog);
    });
    
    // --- Feature Logic: Sites ---
    async function addSite(siteData) {
        const newId = await addToStore(SITES_STORE_NAME, siteData);
        siteData.id = newId;
        sitesDataCache[newId] = siteData;
        addMarkerToMap(siteData);
        renderSidebarLists();
    }
    async function updateSite(siteData) {
        await updateInStore(SITES_STORE_NAME, siteData);
        sitesDataCache[siteData.id] = siteData;
        addMarkerToMap(siteData); // Re-adds/updates marker
        renderSidebarLists();
        // If this site is part of any trail, update those polylines
        Object.values(trailsDataCache).forEach(trail => {
            if (trail.siteIds.includes(siteData.id)) {
                addPolylineToMap(trail);
            }
        });
    }
    window.confirmDeleteSite = (id) => { // Global for popup
        const site = sitesDataCache[id];
        showConfirmDialog("Delete Site", `Are you sure you want to delete "${site.name}"? This will also remove it from any trails.`, async (confirmed) => {
            if (confirmed) {
                showLoading("Deleting site...");
                try {
                    await deleteFromStore(SITES_STORE_NAME, id);
                    if (currentMarkers[id]) map.removeLayer(currentMarkers[id]);
                    delete currentMarkers[id];
                    delete sitesDataCache[id];
                    
                    // Remove site from any trails and update those trails
                    const trailsToUpdate = [];
                    Object.values(trailsDataCache).forEach(trail => {
                        const index = trail.siteIds.indexOf(id);
                        if (index > -1) {
                            trail.siteIds.splice(index, 1);
                            trailsToUpdate.push(updateTrail(trail)); // This will re-render polyline
                        }
                    });
                    await Promise.all(trailsToUpdate);
                    renderSidebarLists();
                } catch (err) {
                    console.error("Error deleting site:", err);
                    alert("Failed to delete site: " + err.message);
                } finally {
                    hideLoading();
                }
            }
        });
    };

    // --- Feature Logic: Trails ---
    async function addTrail(trailData) {
        const newId = await addToStore(TRAILS_STORE_NAME, trailData);
        trailData.id = newId;
        trailsDataCache[newId] = trailData;
        addPolylineToMap(trailData);
        renderSidebarLists();
    }
    async function updateTrail(trailData) {
        await updateInStore(TRAILS_STORE_NAME, trailData);
        trailsDataCache[trailData.id] = trailData;
        addPolylineToMap(trailData);
        renderSidebarLists();
    }
    window.confirmDeleteTrail = (id) => { // Global for popup
        const trail = trailsDataCache[id];
        showConfirmDialog("Delete Trail", `Are you sure you want to delete trail "${trail.name}"?`, async (confirmed) => {
            if (confirmed) {
                showLoading("Deleting trail...");
                try {
                    await deleteFromStore(TRAILS_STORE_NAME, id);
                    if (currentTrailPolylines[id]) map.removeLayer(currentTrailPolylines[id]);
                    delete currentTrailPolylines[id];
                    delete trailsDataCache[id];
                    renderSidebarLists();
                } catch (err) {
                    console.error("Error deleting trail:", err);
                    alert("Failed to delete trail: " + err.message);
                } finally {
                    hideLoading();
                }
            }
        });
    };

    // --- Sidebar & Filtering/Search Logic ---
    function renderSidebarLists() {
        const sitesListUl = document.getElementById('sites-list-sidebar');
        const trailsListUl = document.getElementById('trails-list-sidebar');
        sitesListUl.innerHTML = '';
        trailsListUl.innerHTML = '';

        const filterTypeVal = document.getElementById('filterType').value;
        const filterVisitedVal = document.getElementById('filterVisited').value;
        const localSearchTerm = document.getElementById('localSearchInput').value.toLowerCase();

        // Clear existing markers and polylines from map before re-filtering
        Object.values(currentMarkers).forEach(marker => map.removeLayer(marker));
        currentMarkers = {};
        Object.values(currentTrailPolylines).forEach(polyline => map.removeLayer(polyline));
        currentTrailPolylines = {};
        
        Object.values(sitesDataCache)
            .filter(site => {
                const typeMatch = !filterTypeVal || site.type === filterTypeVal;
                const visitedMatch = !filterVisitedVal || String(site.visitedStatus) === filterVisitedVal;
                const searchMatch = !localSearchTerm || 
                    site.name.toLowerCase().includes(localSearchTerm) ||
                    (site.historicalSignificance && site.historicalSignificance.toLowerCase().includes(localSearchTerm)) ||
                    (site.relatedDuasPractices && site.relatedDuasPractices.toLowerCase().includes(localSearchTerm)) ||
                    (site.personalVisitNotes && site.personalVisitNotes.toLowerCase().includes(localSearchTerm)) ||
                    (site.relatedQuranHadith && site.relatedQuranHadith.toLowerCase().includes(localSearchTerm));
                return typeMatch && visitedMatch && searchMatch;
            })
            .forEach(site => {
                addMarkerToMap(site); // Add filtered markers to map
                const li = document.createElement('li');
                li.textContent = `${site.name} (${site.type})`;
                if (site.visitedStatus) li.textContent += " [Visited]";
                li.onclick = () => {
                    map.setView([site.lat, site.lng], 15);
                    currentMarkers[site.id]?.openPopup();
                };
                sitesListUl.appendChild(li);
            });

        Object.values(trailsDataCache)
            .filter(trail => {
                const searchMatch = !localSearchTerm || 
                    trail.name.toLowerCase().includes(localSearchTerm) ||
                    (trail.description && trail.description.toLowerCase().includes(localSearchTerm));
                // Add trail if its name/desc matches OR if any of its sites match current site filters
                const hasVisibleSite = trail.siteIds.some(siteId => currentMarkers[siteId]); // Check if any site of this trail is visible based on site filters
                return searchMatch || hasVisibleSite;
            })
            .forEach(trail => {
                addPolylineToMap(trail); // Add filtered/relevant trails to map
                const li = document.createElement('li');
                li.textContent = trail.name;
                li.onclick = () => {
                    const siteObjects = trail.siteIds.map(id => sitesDataCache[id]).filter(s => s);
                    if (siteObjects.length > 0) {
                        const bounds = L.latLngBounds(siteObjects.map(s => [s.lat, s.lng]));
                        map.fitBounds(bounds, {padding: [50,50]});
                        currentTrailPolylines[trail.id]?.openPopup();
                    }
                    // Highlight sites in this trail
                    document.querySelectorAll('#sites-list-sidebar li').forEach(sli => sli.classList.remove('active-trail-site'));
                    trail.siteIds.forEach(siteId => {
                        const siteLi = Array.from(document.querySelectorAll('#sites-list-sidebar li')).find(sli => {
                             // This is tricky as li textContent might not be unique or directly map to ID.
                             // A better way would be to store siteId on the li element as a data attribute.
                             // For now, visual feedback on map is primary.
                        });
                        // if (siteLi) siteLi.classList.add('active-trail-site');
                    });
                };
                trailsListUl.appendChild(li);
            });
    }

    // --- Feature Logic: My Location ---
    function findAndShowMyLocation() {
        showLoading("Finding your location...");
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(position => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                map.setView([lat, lng], 13);
                L.circleMarker([lat, lng], {radius: 8, color: varToCss('--accent-hover'), fillColor: varToCss('--accent-color'), fillOpacity: 0.8}).addTo(map)
                 .bindPopup("Your approximate location").openPopup();
                hideLoading();
            }, error => {
                console.error("Error getting location:", error);
                alert("Could not get your location: " + error.message);
                hideLoading();
            });
        } else {
            alert("Geolocation is not supported by your browser.");
            hideLoading();
        }
    }
    
    // --- Feature Logic: Nominatim Search ---
    async function searchNominatim() {
        const query = document.getElementById('nominatimSearchInput').value;
        if (!query) return;
        showLoading("Searching map...");
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Nominatim API error: ${response.statusText}`);
            const data = await response.json();
            if (data && data.length > 0) {
                const item = data[0];
                map.setView([parseFloat(item.lat), parseFloat(item.lon)], 12);
            } else {
                alert("Location not found via external search.");
            }
        } catch (error) {
            console.error("Nominatim search failed:", error);
            alert("External map search failed. Check connection or try again. " + error.message);
        } finally {
            hideLoading();
        }
    }

    // --- Data Management ---
    async function backupData() {
        showLoading("Backing up data...");
        try {
            const allSites = await getAllFromStore(SITES_STORE_NAME);
            const allTrails = await getAllFromStore(TRAILS_STORE_NAME);
            const dataToBackup = { sites: allSites, trails: allTrails, backupVersion: 1, app: "IslamicSitesAtlasMyData" };
            const jsonData = JSON.stringify(dataToBackup, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const date = new Date().toISOString().slice(0,10);
            a.href = url;
            a.download = `islamic_sites_atlas_backup_${date}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert("Backup successful! File downloaded.");
        } catch (err) {
            console.error("Backup failed:", err);
            alert("Backup failed: " + err.message);
        } finally {
            hideLoading();
        }
    }

    function handleRestoreFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        showConfirmDialog("Restore Data", "Restoring will overwrite ALL current data. Are you sure you want to proceed?", (confirmed) => {
            if (confirmed) {
                showLoading("Restoring data...");
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const restoredData = JSON.parse(e.target.result);
                        if (!restoredData.app || restoredData.app !== "IslamicSitesAtlasMyData" || !restoredData.sites || !restoredData.trails) {
                            throw new Error("Invalid or incompatible backup file.");
                        }

                        await clearStore(SITES_STORE_NAME);
                        await clearStore(TRAILS_STORE_NAME);
                        
                        currentMarkers = {};
                        sitesDataCache = {};
                        currentTrailPolylines = {};
                        trailsDataCache = {};
                        // Clear map layers (alternative to full reload)
                        map.eachLayer(layer => { if (!!layer.toGeoJSON) map.removeLayer(layer); }); // Removes markers/polylines
                        // Re-add base tile layer
                         L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors. App by Yasin Ullah.'
                        }).addTo(map);


                        for (const site of restoredData.sites) {
                            // Ensure ID is not passed if store is autoIncrement and we want new IDs
                            // However, for restore, we usually want to keep original IDs.
                            // This assumes the store setup allows specifying IDs or they are part of the object.
                            // If keyPath is 'id' and autoIncrement is true, adding with existing id might fail or behave unexpectedly.
                            // Best practice for restore: clear store, then add. IDB handles key generation IF not provided.
                            // If we provide `id`, it will use that.
                            delete site.id; // Let IDB assign new IDs to prevent conflicts if schema changed or IDs were not unique
                            await addSite(site); // addSite handles cache and map
                        }
                        for (const trail of restoredData.trails) {
                            delete trail.id;
                            // Remap site IDs if they changed during site restoration (if sites were added without their original IDs)
                            // This is complex. For simplicity, assume site IDs in trails are still valid or sites are restored with original IDs.
                            // If site IDs are re-generated, trails will break.
                            // The current addSite/addTrail will get new IDs. This is problematic for trails.
                            // Solution: Restore with original IDs if possible.
                            // The current `addToStore` will generate new IDs. We need a way to insert with ID.
                            // `store.put(data)` will use `data.id` if present, or add if not. This is better for restore.
                            // Let's modify restore to use `put` directly after clearing.
                        }
                        // Simpler restore:
                        await clearStore(SITES_STORE_NAME);
                        for(const site of restoredData.sites) {
                            await dbTransaction(SITES_STORE_NAME, 'readwrite', (store, resolve) => store.put(site).onsuccess = resolve);
                        }
                        await clearStore(TRAILS_STORE_NAME);
                        for(const trail of restoredData.trails) {
                            await dbTransaction(TRAILS_STORE_NAME, 'readwrite', (store, resolve) => store.put(trail).onsuccess = resolve);
                        }

                        await loadAllDataFromDB(); // Reload everything from DB
                        alert("Data restored successfully!");
                    } catch (err) {
                        console.error("Restore failed:", err);
                        alert("Restore failed: " + err.message + ". Data might be partially restored or corrupted.");
                    } finally {
                        hideLoading();
                        document.getElementById('restoreFile').value = ''; // Reset file input
                    }
                };
                reader.readAsText(file);
            } else {
                 document.getElementById('restoreFile').value = ''; // Reset file input
            }
        });
    }
    
    // --- Initial Data Load & Refresh ---
    async function loadAllDataFromDB() {
        showLoading("Loading data...");
        try {
            const sites = await getAllFromStore(SITES_STORE_NAME);
            sitesDataCache = {};
            sites.forEach(site => sitesDataCache[site.id] = site);

            const trails = await getAllFromStore(TRAILS_STORE_NAME);
            trailsDataCache = {};
            trails.forEach(trail => trailsDataCache[trail.id] = trail);
            
            renderSidebarLists(); // This also (re)populates the map
        } catch (err) {
            console.error("Error loading data from DB:", err);
            alert("Failed to load data: " + err.message);
        } finally {
            hideLoading();
        }
    }

    // --- Event Listeners Setup ---
    function setupEventListeners() {
        document.getElementById('addSiteBtn').addEventListener('click', () => openSiteFormForAdd(map.getCenter()));
        document.getElementById('createTrailBtn').addEventListener('click', () => openTrailForm());
        document.getElementById('myLocationBtn').addEventListener('click', findAndShowMyLocation);
        document.getElementById('nominatimSearchBtn').addEventListener('click', searchNominatim);
        document.getElementById('nominatimSearchInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') searchNominatim(); });
        
        document.getElementById('filterType').addEventListener('change', renderSidebarLists);
        document.getElementById('filterVisited').addEventListener('change', renderSidebarLists);
        document.getElementById('localSearchInput').addEventListener('input', renderSidebarLists);

        document.getElementById('backupBtn').addEventListener('click', backupData);
        document.getElementById('restoreBtn').addEventListener('click', () => document.getElementById('restoreFile').click());
        document.getElementById('restoreFile').addEventListener('change', handleRestoreFileSelect);

        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            sidebarToggle.classList.toggle('on-sidebar');
            sidebarToggle.textContent = sidebar.classList.contains('open') ? '✕' : '☰';
        });
    }

    </script>
</body>
</html>